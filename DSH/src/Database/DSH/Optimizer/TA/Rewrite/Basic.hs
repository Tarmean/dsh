{-# LANGUAGE TemplateHaskell #-}

module Database.DSH.Optimizer.TA.Rewrite.Basic where
       
import Debug.Trace
import Text.Printf
       
import Control.Applicative
import Control.Monad
import Data.Maybe
import qualified Data.Set.Monad as S

import Database.Algebra.Dag.Common
import Database.Algebra.Pathfinder.Data.Algebra

import Database.DSH.Impossible
import Database.DSH.Optimizer.Common.Rewrite
import Database.DSH.Optimizer.TA.Rewrite.Common
import Database.DSH.Optimizer.TA.Properties.Types

cleanup :: TARewrite Bool
cleanup = iteratively $ sequenceRewrites [ applyToAll noProps cleanupRules 
                                         , applyToAll inferAll cleanupRulesTopDown 
                                         ]

cleanupRules :: TARuleSet ()
cleanupRules = [ stackedProject ]

cleanupRulesTopDown :: TARuleSet AllProps
cleanupRulesTopDown = [ unreferencedRownum 
                      , unreferencedRank
                      , unreferencedProjectCols
                      , unreferencedAggrCols
                      , postFilterRownum
                      ]

----------------------------------------------------------------------------------
-- Rewrite rules

mergeProjections :: [Proj] -> [Proj] -> [Proj]
mergeProjections proj1 proj2 = map (\(c, e) -> (c, inline e)) proj1

  where
    inline :: Expr -> Expr
    inline (BinAppE op e1 e2) = BinAppE op (inline e1) (inline e2)
    inline (UnAppE op e)      = UnAppE op (inline e)
    inline (ColE c)           = fromMaybe (failedLookup c) (lookup c proj2)
    inline (ConstE val)       = ConstE val

    failedLookup :: AttrName -> a
    failedLookup c = trace (printf "mergeProjections: column lookup %s failed\n%s\n%s"
                                   c (show proj1) (show proj2))
                           $impossible

stackedProject :: TARule ()
stackedProject q =
  $(pattern 'q "Project ps1 (Project ps2 (qi))"
    [| do
         return $ do
           let ps = mergeProjections $(v "ps1") $(v "ps2")
           logRewrite "Basic.Project.Merge" q
           void $ replaceWithNew q $ UnOp (Project ps) $(v "qi") |])
           

-- | Eliminate rownums which re-generate positions based on one
-- sorting column. These rownums typically occur after filtering
-- operators, i.e. select, antijoin, semijoin. If the absolute values
-- generated by the rownum are not required and only the encoded order
-- is relevant, we can safely remove the rownum and use the sorting
-- column. In that case, positions might not be dense anymore.

-- FIXME this needs to be restricted further. In order to be sound,
-- the rownum input which we reuse has to be of type int.
postFilterRownum :: TARule AllProps
postFilterRownum q =
  $(pattern 'q "RowNum args (q1)"
    [| do
        (res, [(sortCol, _)], _) <- return $(v "args")
        useCols <- pUse <$> td <$> properties q
        keys    <- pKeys <$> bu <$> properties $(v "q1")
        cols    <- pCols <$> bu <$> properties $(v "q1")

        -- To get rid of the rownum, the absolute values generated by
        -- it must not be required.
        predicate $ not $ res `S.member` useCols

        -- Rownum produces a key. If we remove the rownum because its
        -- absolute values are not needed and replace it with the
        -- original sorting column, it should still be a key.
        predicate $ (S.singleton sortCol) `S.member` keys

        -- If we reuse a sorting column, it's type should be int.
        predicate $ AInt == typeOf sortCol cols 

        return $ do
          logRewrite "Basic.Rownum.Unused" q
          let projs = (res, ColE sortCol) : map (\c -> (c, ColE c)) (map fst $ S.toList cols)
          void $ replaceWithNew q $ UnOp (Project projs) $(v "q1") |])
       

---------------------------------------------------------------------------
-- ICols rewrites 

-- | Prune a rownumber operator if its output is not required
unreferencedRownum :: TARule AllProps
unreferencedRownum q = 
  $(pattern 'q "RowNum args (q1)"
    [| do
         (res, _, _) <- return $(v "args")
         neededCols  <- pICols <$> td <$> properties q
         predicate $ not (res `S.member` neededCols)
         
         return $ do
           logRewrite "Basic.ICols.Rownum" q
           replace q $(v "q1") |])

-- | Prune a rownumber operator if its output is not required
unreferencedRank :: TARule AllProps
unreferencedRank q = 
  $(pattern 'q "[Rank | RowRank] args (q1)"
    [| do
         (res, _) <- return $(v "args")
         neededCols  <- pICols <$> td <$> properties q
         predicate $ not (res `S.member` neededCols)
         
         return $ do
           logRewrite "Basic.ICols.Rank" q
           replace q $(v "q1") |])

-- | Prune projections from a project operator if the result columns
-- are not required.
unreferencedProjectCols :: TARule AllProps
unreferencedProjectCols q =
  $(pattern 'q "Project projs (q1)"
    [| do
        neededCols <- pICols <$> td <$> properties q
        let neededProjs = filter (flip S.member neededCols . fst) $(v "projs")

        -- Only modify the project if we could actually get rid of some columns.
        predicate $ length neededProjs < length $(v "projs")

        return $ do
          logRewrite "Basic.ICols.Project" q
          void $ replaceWithNew q $ UnOp (Project neededProjs) $(v "q1") |])

-- | Remove aggregate functions whose output is not referenced.
unreferencedAggrCols :: TARule AllProps
unreferencedAggrCols q =
  $(pattern 'q "Aggr args (q1)"                     
    [| do
        neededCols <- pICols <$> td <$> properties q
        (aggrs, partCols) <- return $(v "args")

        let neededAggrs = filter (flip S.member neededCols . snd) aggrs

        predicate $ length neededAggrs < length aggrs

        return $ do
          case neededAggrs of
              -- If the output of all aggregate functions is not
              -- required, we can replace it with a distinct operator
              -- on the grouping columns.
              [] -> do
                  logRewrite "Basic.ICols.Aggr.Prune" q
                  projectNode <- insert $ UnOp (Project partCols) $(v "q1")
                  void $ replaceWithNew q $ UnOp (Distinct ()) projectNode
          
              -- Otherwise, we just prune the unreferenced aggregate functions
              _ : _ -> do
                  logRewrite "Basic.ICols.Aggr.Narrow" q
                  void $ replaceWithNew q $ UnOp (Aggr (neededAggrs, partCols)) $(v "q1") |])



