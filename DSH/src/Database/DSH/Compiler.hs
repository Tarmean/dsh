{-# LANGUAGE TemplateHaskell #-}

-- | This module provides the flattening implementation of DSH.
module Database.DSH.Compiler
  ( -- * Running queries via the Flattening backend
    fromQ
    -- * Debug functions
  , debugSQL
  , debugNKL
  , debugFKL
  , debugVL
  , debugPFXML
  , debugTA
  ) where

import           Database.DSH.CompileFlattening
import           Database.DSH.ExecuteFlattening

import           Database.DSH.Internals
import           Database.HDBC
import qualified Database.HDBC                                   as H

import qualified Database.DSH.CL.Lang                 as CL
import qualified Database.DSH.CL.Opt                  as CLOpt
import qualified Database.DSH.Common.Data.Type        as T
import           Database.DSH.Export
import           Database.DSH.Optimizer.VL.OptimizeVL
import           Database.DSH.Translate.Algebra2Query
import           Database.DSH.Translate.CL2NKL
import           Database.DSH.Translate.FKL2VL
import           Database.DSH.Translate.NKL2FKL
import           Database.DSH.Translate.VL2Algebra
import qualified Database.DSH.VL.Data.Query           as Q

import qualified Data.List                                       as L

import           Control.Applicative

import           Data.Convertible                                ()

(|>) :: a -> (a -> b) -> b
(|>) = flip ($)

-- Different versions of the flattening compiler pipeline

nkl2SQL :: CL.Expr -> (Q.Query Q.SQL, T.Type)
nkl2SQL e = let (e', t) = nkl2Alg e
            in (generateSQL e', t)

nkl2Alg :: CL.Expr -> (Q.Query Q.XML, T.Type)
nkl2Alg e = let q       = desugarComprehensions e
                          |> flatten
                          |> specializeVectorOps
                          |> implementVectorOpsPF
                          |> generatePFXML
                t       = T.typeOf e
            in (q, t)

nkl2TAFile :: String -> CL.Expr -> IO ()
nkl2TAFile prefix e = desugarComprehensions e
                        |> flatten
                        |> specializeVectorOps
                        |> implementVectorOpsPF
                        |> (exportTAPlan prefix)

nkl2SQLFile :: String -> CL.Expr -> IO ()
nkl2SQLFile prefix e = desugarComprehensions e
                       |> flatten
                       |> specializeVectorOps
                       |> implementVectorOpsPF
                       |> generatePFXML
                       |> generateSQL
                       |> (exportSQL prefix)

nkl2XMLFile :: String -> CL.Expr -> IO ()
nkl2XMLFile prefix e = desugarComprehensions e
                       |> flatten
                       |> specializeVectorOps
                       |> implementVectorOpsPF
                       |> generatePFXML
                       |> (exportPFXML prefix)

nkl2VLFile :: String -> CL.Expr -> IO ()
nkl2VLFile prefix e = desugarComprehensions e
                      |> flatten
                      |> specializeVectorOps
                      |> optimizeVLDefault
                      |> exportVLPlan prefix


-- Functions for executing and debugging DSH queries via the Flattening backend

-- | Compile a DSH query to SQL and run it on the database given by 'c'.
fromQ :: (QA a, IConnection conn) => conn -> Q a -> IO a
fromQ c (Q a) =  do
                   (q, _) <- nkl2SQL <$> toComprehensions (getTableInfo c) a
                   frExp <$> (executeSQLQuery c $ SQL q)

-- | Debugging function: return the NKL (Nested Kernel Language) representation of a
-- query (SQL version)
debugNKL :: (QA a, IConnection conn) => conn -> Q a -> IO String
debugNKL c (Q e) = show <$> desugarComprehensions <$> CLOpt.opt <$> toComprehensions (getTableInfo c) e

-- | Debugging function: return the FKL (Flat Kernel Language) representation of a
-- query (SQL version)
debugFKL :: (QA a, IConnection conn) => conn -> Q a -> IO String
debugFKL c (Q e) = show <$> flatten <$> desugarComprehensions <$> toComprehensions (getTableInfo c) e

debugTA :: (QA a, IConnection conn) => String -> conn -> Q a -> IO ()
debugTA prefix c (Q e) = do
              e' <- CLOpt.opt <$> toComprehensions (getTableInfo c) e
              nkl2TAFile prefix e'

-- | Debugging function: dump the VL query plan (DAG) for a query to a file (SQL version).
debugVL :: (QA a, IConnection conn) => String -> conn -> Q a -> IO ()
debugVL prefix c (Q e) = do
  e' <- CLOpt.opt <$> toComprehensions (getTableInfo c) e
  nkl2VLFile prefix e'

-- | Debugging function: dump the Pathfinder Algebra query plan (DAG) to XML files.
debugPFXML :: (QA a, IConnection conn) => String -> conn -> Q a -> IO ()
debugPFXML prefix c (Q e) = do
  e' <- CLOpt.opt <$> toComprehensions (getTableInfo c) e
  nkl2XMLFile prefix e'

-- | Debugging function: dump SQL queries generated by Pathfinder to files.
debugSQL :: (QA a, IConnection conn) => String -> conn -> Q a -> IO ()
debugSQL prefix c (Q e) = do
  e' <- CLOpt.opt <$> toComprehensions (getTableInfo c) e
  nkl2SQLFile prefix e'

-- | Retrieve through the given database connection information on the table (columns with their types)
-- which name is given as the second argument.
getTableInfo :: IConnection conn => conn -> String -> IO [(String, (T.Type -> Bool))]
getTableInfo c n = do
                 info <- H.describeTable c n
                 return $ toTableDescr info

     where
       toTableDescr :: [(String, SqlColDesc)] -> [(String, (T.Type -> Bool))]
       toTableDescr = L.sortBy (\(n1, _) (n2, _) -> compare n1 n2) . map (\(name, props) -> (name, compatibleType (colType props)))
       compatibleType :: SqlTypeId -> T.Type -> Bool
       compatibleType dbT hsT = case hsT of
                                     T.UnitT -> True
                                     T.BoolT -> L.elem dbT [SqlSmallIntT, SqlIntegerT, SqlBitT]
                                     T.StringT -> L.elem dbT [SqlCharT, SqlWCharT, SqlVarCharT]
                                     T.IntT -> L.elem dbT [SqlSmallIntT, SqlIntegerT, SqlTinyIntT, SqlBigIntT, SqlNumericT]
                                     T.DoubleT -> L.elem dbT [SqlDecimalT, SqlRealT, SqlFloatT, SqlDoubleT]
                                     t       -> error $ "You can't store this kind of data in a table... " ++ show t ++ " " ++ show n
