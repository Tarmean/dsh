\newpage
\chapter{Vectorising}
\label{chap_Vec}

Translating the flattened code into algebraic code seems to be a very big step. In fact it are two steps that are taken at once (namely vectorization and algebraic compilation). In this chapter we propose an intermediate step that performs only the vectorization step. Some of the flattened operations already directly map to vector operations, for other operations such an alternative translation isn't as obvious. 

In this Chapter we discuss how we will represent vectorised data. And provide a translation scheme that transforms a flattened program into a vectorised program.  

\section{Towards simpler compilation rules}

In order to eliminate some operations that don't have an obvious translation to algebraic code we introduce a range of helper functions that operate on the level of a vector representation. We describe the intuition of each of these functions and give an implementation in Haskell for each of them, in the next chapter we show how these primitives can be translated into table algebra.

\subsection{Type language}

Let us begin by describing the types of vectors we have:

As mentioned earlier a list value of type |[[a]]| is represented by a series of vectors | v_a || d_a_1, d_a_2 |. 

We distinguish between several types of vectors. The type of |d_a_2| is | Descriptor |. As the type-name suggests this vector describes the structure of a level of nesting. A descriptor is a vector of tuples, where each tuple contains a description and position field. Value vectors (such as: |v_a || d_a_1|) are a variation on descriptor vectors, the tuple is expanded and contains an extra value element. The type of a value vector is | ValueVector |. Some primitive operations behave the same for |ValueVector| and |Descriptor|, we therefor add an extra type |Vector a| that can be either of them. 

A sequence of descriptor vectors ending with a value vector (| v_a || d_a_1, d_a_2, ..., d_a_n |) has type |NVector n| where n is a type level number describing the nesting depth. A value of type |NVector 1| is just a value vector and the type | ValueVector | is thus equivalent.
A last type of vector are propagation vectors with type | PropVector |. These vectors describe how to transform value and descriptor vectors.

Primitive Haskell values (such as |Int, Bool, Char| etc.) are represented by the type |Val|.

Propagation vectors are used to propagate changes through other vectors, these changes range from duplication to reordering. Propagation vectors consist of two columns |pnew| and |pold|. It is required that these vectors are ordered by the |pnew| column.

Renaming vectors are used to rename vectors. Renaming vector can not be used to perform reordering or duplication. They can be used to eliminate values. Renaming vectors have the same layout as propagation vectors. It is required for a renaming vector that both |pnew| and |pold| are strictly ascending. And |pnew| has to be dense. 

Following from the above descriptions we can derive that every renaming vector is also a propagation vector, but not all propagation vectors are renaming vectors. We therefor allow renaming vectors to be used as propagation vector but not the other way around.

\subsection{Primitive functions}

We define the following primitive operations:
\begin{code}
outer :: NVector n -> DescrVector
dist_prim :: Val -> DescrVector -> ValueVector
dist_desc :: Vector a -> Vector b -> (Vector a, PropVector)
dist_lift :: Vector a -> Vector b -> (Vector a, PropVector)
propagateIn :: PropVector -> Vector a -> (Vector a, PropVector)
rename :: RenameVector -> Vector a -> Vector a
attach :: DescVector -> NVector n -> NVector (n + 1)
singleton_prim :: Val -> NVector 1
singleton_vec :: NVector n -> NVector (n + 1)
append :: Vector a -> Vector a -> (Vector a, RenameVector, RenameVector)
segment :: Vector a -> Vector a
restrict_vec :: Vector a -> NVector 1 -> (Vector a, RenameVector)
combine_vec :: NVector 1 -> Vector a -> Vector a -> (Vector a, RenameVector, RenameVector)
bPermute_vec :: Vector a -> NVector 1 -> (Vector a, PropVector)
length :: Vector a -> Val
length_seg :: DescVector -> Vector a -> ValueVector
descToProp :: DescVector -> PropVector
notPrim :: Val -> Val
notVec :: ValueVector -> ValueVector
groupBy :: ValueVector -> Vector a -> (DescrVector, Vector a, PropVector)
\end{code}
% interleave :: Vector a -> Vector a -> (Vector a, PropVector, PropVector)

Let us now describe the workings of these functions.
%{
%include algebra2.fmt

\subsubsection*{Definition of |index_vec|}

The function |index_vec| has type: |NVector 1 -> Val -> Val|.
The first argument is a vector of primitive values, the second an integer value. The function then returns a value form the vector.
|index_vec| is implemented in algebra as:
\begin{infrules}
    \infrule[index-vec]
        {| +- e1 => e1' |\quad| +- e2 => e2' |}
        {| +- index_vec e1 e2 => attachA p 1 (attachA d 1 (proj i (join (p == i') e1' (proj (i' <- i) e2'))))|}
\end{infrules}

\subsubsection*{Definition of |index_desc|}

The function |index_desc| has type: |DescVector -> Val -> PropVector|. The first argument is a descriptor vector, the second argument an integer value. The function return a propagation vector describing how to rename nested vectors in order to get the nth element.

\begin{infrules}
    \infrule[index-desc]
        {| +- e1 => e1' |\quad| +- e2 => e2'|}
        {| +- index_desc e1 e2 => attachA pnew 1 (proj (pold <- p) (join (p == i) e1' (proj i e2')))|}
\end{infrules}

\subsubsection*{Definition of |outer|}

The function |outer| of type: |NVector n -> DescrVector| is a compile time operation. It extracts the outer descriptor vector of a nested vector.

\subsubsection*{Definition of |dist_prim|}

The function |dist_prim| distributes a primitive value over a descriptor, resulting in a list where each element is the primitive element.

Assume now that the descriptor is instantiated as a value vector. This value vector in the Haskell world would represent a list with type |[a]| (for some type a). 

A version of |dist_prim| for Haskell values would be specified as follows:
\begin{code}
dist_prim :: Prim a => a -> [b] -> [a]
dist_prim a xs = map (const a) xs
\end{code}

In the case that we want to distribute a (nested) list |a| over another list |b| | dist_prim | will not suffice.

The result will be a list of vectors which one vector longer than the list of vectors representing |a|. The extra outer vector is the outermost vector of |b|. In the case that |b| is just a value-vector all values can be discarded transforming |b| into an ordinary descriptor.

It's defined in algebra as:
\begin{infrules}
    \infrule[distPrim]
        {| +- e1 => q1 |\quad | +- e2 => q2|}
        {| +- dist_prim e1 e2 => cross q1 q2 |}
\end{infrules}

\subsubsection*{Definition of |dist_desc|}
This function distributes a value or descriptor vector over another vector. It results in a new vector and a propagation vector that can be used to propagate the distribution to the inner vectors. The vector represented by e2 should be used afterwards as the outer vector.

The algebraic definition of |dist_desc|:
\begin{infrules}
    \infrule[distDesc]
        {| +- e1 => q1 |\quad | +- e2 => q2|\\
         | q = proj (d <- p, p <- p'', pold, [i]) (rownum p'' (p:p')(cross (proj p q2) (proj (p' <- p, pold <- p) q1)))|}
        {| +- dist_desc e1 e2 => (proj (d,p,[i]) q, proj (pold, pnew <- p'') q)|}
\end{infrules}

\subsubsection*{Definition of |dist_lift|}

This function distributes a value or descriptor vector over another vector with lifted semantics. The result does not provide an outer descriptor this vector should be the vector that was the outer vector of the second argument.

In algebra it is defined as:
\begin{infrules}
    \infrule[distLift]
        {| +- e1 => q1 |\quad| +- e2 => q2 |\\
         | q = join (p'==d) (proj (p' <- p, [i]) q1) (proj (d,p) q2)|}
        {| +- dist_lift e1 e2 => (proj (d, p, [i]) q, proj (pold <- p', pnew <- p) q)|}
\end{infrules}

\subsubsection*{Definition of |rename|}

The operation rename uses a propagation vector to rename the descriptor values of a vector. The descriptor column of a vector is (except for the outermost descriptor vector) a foreign-key column relating it to an outer vector. When the key values in this outer vector are changed a propagation vector describing these changes is generated. 

A definition of this function in algebra:
\begin{infrules}
    \infrule[rename]
        {| +- p => pv |\quad | +- e => qe |}
        {| +- rename p e => proj (d:pnew, p, [i]) (join (pold = d) pv qe)|}
\end{infrules}

\subsubsection*{Definition of |propagateIn|}

This function is similar to |rename|. It renames the descriptor column but afterwards recomputes the position column. It will result in a new descriptor/value vector and a propagation vector describing the changes made by recomputing the pos column.

A definition of this function in algebra:
\begin{infrules}
    \infrule[propagateIn]
        {| +- p => pv |\quad | +- e => qe |\\
         | q' = rownum p' (<pnew:p>) (join (pold = d) pv qe)|}
        {| propagateIn p e => (proj (d <- pnew, p <- p', [i]) q', proj (pold <- p, pnew <- p') q')|}
\end{infrules}

\subsubsection*{Definition of |attach|}

The function |attach| is the inverse of |outer|, and like |outer| is a compile time operation. It attaches a new descriptor vector to a (nested-) vector, thereby adding a level of nesting. 

\subsubsection*{Definition of |singleton_prim|}

The function |singleton_prim| transforms a primitive value into a singleton list. 
In Haskell it would be defined as:
\begin{code}
singleton_prim :: Prim a => a -> [a]
singleton_prim x = [x]
\end{code}

In algebra it is defined as:
\begin{infrules}
    \infrule[singleton-prim]
        {| e => q |}
        {| +- singleton_prim e => attachA d 1 (attachA p 1 q)|}
\end{infrules}
\subsubsection*{Definition of |singleton_vec|}
The function |singleton_vec| adds another nesting layer to a vector.

In algebra it is defined as:
\begin{infrules}
    \infrule[singleton-prim]
        {| +- e => q |}
        {| +- singleton_vec e => patV singletonDescr q|}
\end{infrules}

\subsubsection*{Definition of |append|}
The function |append|, performs a segmented append of two vectors. A vector is said to be segmented when in its descriptor column different descriptor values are provided. The intuition is that if two segments appear in both vectors (that is both vectors have segments with the same descriptor value) these two segments are grouped together with the same segment name and the items are in the same order as in the individual vectors with all values from the first vector before the elements of the second vector. All segments in the resulting vectors are ordered by their segment number. The position fields are updated to reflect the new absolute position of elements in the new vector. The result of the append function are three vectors. The appended vector, and two vectors describing how the position values in the original vectors where changed.

This segmented append shows interleaving behaviour when two equally segmented vectors are appended, for vectors where the segments of the second vector have a greater descriptor than the descriptor values in the first vector it behaves as the more regular append for vector, that just concatenates the two vectors.

A definition of this function in algebra:
\begin{infrules}
    \infrule[append]
        {| +- e1 => q1|\quad| +- e2 => q2|\\
         | q = rownum p' (d:o:p) (union (attachA o 1 q1) (attachA o 2 q2))|}
        {| +- append e1 e2 => (proj (p <- p', d, [i]) q, proj (pold <- p, pnew <- p') (sel (o==1) q), proj (pold <- p, pnew <- p') (sel (o==2) q)) |}
\end{infrules}

%\subsubsection*{Definition of |interleave|}
%
%% Turns out to be the same as append, updated description of append to deal with this
%The function |interleave| performs a form interleaving based on the descriptor column. It produces the new interleaved vector as well as two vector describing the changes to the pos columns of the original vectors.
%
%The function is defined in algebra as:
%\begin{infrules}
%    \infrule[interleave]
%        {| +- e1 => q1 |\quad | +- e2 => q2 |\\
%         | let q = rownum p' (d:o:p) (union (attachA o 1 q1) (attachA o 2 q2)) |}
%        {| +- interleave e1 e2 => (proj (d, p <- p', [i]) q, proj (pold <- p, pnew <- p') (sel (o==1) q), proj (pold <- p, pnew <- p') (sel (o==2) q))|}
%\end{infrules}
%
\subsubsection*{Definition of |segment|}

The segment operator puts every element in a separate list context. It does so by copying the position data (unique for every element) over the descriptor data. Note however that this does not result in an extra outer descriptor to introduce a new level of nesting.

The definition in algebra is: 
\begin{infrules}
    \infrule[segment]
        {| +- e => q |}
        {| +- segment e => proj (d <- p, p, [i]) q|}
\end{infrules}

\subsubsection*{Definition of |extract|}

The |extract| operation is a compile-time operation. It removes |n| descriptor vectors from a value and then returns the remaining vectors.

\subsubsection*{Definition of |insert|}

Like |extract| the |insert| operation is a compile-time operation. It attach |n| descriptor vectors from the first nested vector to the second value.

\subsubsection*{Definition of |restrict_vec|}

The function |restrict_vec| uses its second argument (a value vector  containing boolean values) as a mask on its first argument. It removes every element from the first vector that have a |False| value at its corresponding position in the second vector. It returns the new filtered vector and a propagation vector describing the changes of positions of the elements that remain in the vector. 

It is defined in algebra as:
\begin{infrules}
    \infrule[restrictVec]
        {| +- e1 => q1 |\quad| +- e2 => q2 |\\
         | q = rownum p'' p (sel i' (join (p == p') q1 (proj (p' <- p, i' <- i) q2)))|}
        {| +- restrict_vec e1 e2 => (proj (p <- p'', d, [i]) q, proj (pold <- p, pnew <- p'') q)|}
\end{infrules}

\subsubsection*{Definition of |combine_vec|}

The function |combine_vec| combines two vectors into one new vector following the description give by a boolean vector. At position corresponding to the value |True| a value from the first vector will be used, at other places a value from the second vector.

It is defined in algebra as:
\begin{infrules}
    \infrule[combineVec]
        {| +- eb => qb |\quad| +- e1 => q1 |\quad| +- e2 => q2|\\
         | d1 = proj (p', p) (rownum p' p (sel i qb)) | \quad | d2 = proj (p', p) (rownum p' p (sel (not i) qb)) |\\
         | q = union ((join (p'==pold) d1 (proj (pold <- p, d, [i]) q1))) ((join (p'==pold) d2 (proj (pold <- p, d, [i]) q2)))|}
        {| +- combine_vec eb e1 e2 => (proj (d, p, [i]) q, proj (pold <- p', pnew <- p) d1, proj (pold <- p', pnew <- p) d2)|}
\end{infrules}

\subsubsection*{Definition of |bPermute_vec|}

During flattening the combinator |back_permute| is introduced, this combinator is also a primitive vector operation. In contrast to the version introduced during flattening this version also applies to nested vectors. The support for nested vectors comes by the propagation vector that can be |chainPropagated| through the nested vectors.
It is defined as:

\begin{infrules}
    \infrule[bPermute]
        {| +- e1 => q1 |\quad| +- e2 => q2 |\\
         | q = join (p==p') q1 (proj (p' <- p, pnew <- i) q2)|}
        {| +- bPermute_vec e1 e2 => (proj (d, p <- pnew, [i]) q, proj (pold <- p, pnew) q) |}
\end{infrules}

\subsubsection*{Definition of |length|}

The operation |length| determines the length of \emph(any) given vector.

\begin{infrules}
    \infrule[length]
        {| +- e1 => q1 |}
        {| +- length e1 => attachA iter 1 (attachA pos 1 (aggr (item1:Max(item1)) (union nullVal (aggr (item1:Count)(proj (p) q1)))))|}
\end{infrules}

\subsubsection*{Definition of |length_seg|}

This operation performs segmented length operation. It computes the length of each \emph{descr} group.

\begin{infrules}
    \infrule[lengthSeg]
        {| +- e1 => q1 |\quad| +- e2 => q2|\\
         | q = cross nullVal (proj (d <- p) q1) |}
        {| +- length_seg e1 e2 => rownum p d (aggr (item1:Max(item1)/d) (union q (aggr (item1:Count/d) (proj (d) q2))))|}
\end{infrules}

\subsubsection*{Definition of |descToProp|}

This operation casts a descriptor vector into a propagation vector. The position column will serve as the old position column in the propagation vector. The descriptor column will be projected to the new position column.

\begin{infrules}
    \infrule[descToProp]
        {| +- e1 => q1 |}
        {| +- descToProp e1 => proj (pnew <- d, pold <- p) q1 |}
\end{infrules}

\subsubsection*{Definition of |groupBy|}

This operations groups a vector as described by a value vector, all indices in the second argument for which the corresponding field in the value vector contains the same value are grouped together. An additional descriptor is returned to represent the extra layer of nesting, the reshaped vector and a propagation vector are also returned.

\begin{infrules}
    \infrule[groupBy]
        {| +- g => v1 |\quad| +- e => v2 |\\
         | q' = rownum p' (r, p) (rank r (d, i) v1) |\\
         | d1 = distinct (proj (d, p <- r) q') |\\
         | p = proj (pold <- p, pnew <- p') q'|\\
         | v = proj (d, p, [i]) (join (p''==p') (proj (d <- r, p <- p', p'' <- p) q') (proj (p' <- p, [i]) v2))|}
        {| groupBy g e =>  (d1, v, p) |}
\end{infrules}

%}
\subsection{Syntactic sugar}

In this section we introduce a bit of syntactic sugar for notational convenience, more specifically we define a form of pattern matching.

In the transformation it is often required to gain access to the outermost descriptor and and the rest of the sequence of vectors. For a vectorised value |x| with vector type |NVector n| (where |n > 1|) we can write |outer x| to get the outermost descriptor vector, and |extract 1 x| to access the tail of the vector sequence. Writing this explicitly in the transformation is rather verbose and thus we define pattern matching to do this. 
We write:
\begin{code}
(patV d1 vss) = x
\end{code}
The value |d1| is now defined as |outer x|, and |vss| is defined as | extract 1 x|. These patterns only occur on the left-hand-side of a binding. On the right-hand-side |(patV d1 vss)| is defined as |attach d1 vss|.

\subsection{Translating types}

In this section we will describe how we translate the regular Haskell types of our flattened program into vector types. Some type information is lost in this
translation, as the exact types of primitive values do not matter that anymore (and we have already established that the program is type correct at this point). 

Let us first define our type language |vecT|:

\begin{syntaxdefs}
    \syntaxdef{|vecT|}
        \alt{|vecT -> vecT|}
        \alt{|Vec n|}
        \alt{|Val|} 
        \alt{|DescrVector|}
        \alt{|ValueVector|}
        \alt{|Vector vt|}
        \alt{|NVector n|}
        \alt{|PropVector|}
        \alt{|RenameVector|}
    \syntaxdef{|vt|}
        \alt{|VVT|}
        \alt{|DVT|}
    \syntaxdef{|n|}
        \alt{|{ num elem Nat }|}
\end{syntaxdefs}

Values of type |Val| represent a non-list (or atomic) value. Values of this type are represented by the following data-type:

\begin{code}
data Val = VChar Pos Char
         | VInt  Pos Int
         | ... 
\end{code}

Values of type |DescrVector| are descriptor vectors that describe
the structure of a nesting level. It is a synonym for the somewhat 
more general |Vector a| that can be either this or a value vector.

Values of type |ValueVector| represent a list of values. Their datatype representation is a vector of triples (description, position and value).
\begin{code}

data DVT where -- Plain Data vector

data VVT where -- Value Vector
    
data Vector a where
        Descriptor :: [(Descr, Pos)] -> Vector DVT
        VVec :: [(Descr, Pos, Val)] -> Vector VVT

type ValueVector = Vector VVT
type DescrVector = Vector DVT
\end{code}

Values of type |Vec n| represent a (nested list of type with nesting depth n). They are represented internally in terms of values of type |DescrVector| and |ValueVector|. It is defined as:

\begin{code}
data NVector n where
    Nest :: DescrVector -> NVector n -> NVector (n + 1)
    List :: ValueVector -> NVector 1
    
unwrap :: NVector 1 -> ValueVector
unwrap (List v) = v

wrap :: ValueVector -> NVector 1
wrap = List

\end{code}
The functions |wrap| and |unwrap| are applied implicitly, and we will treat values of type |NVector 1| as equivalent to values |ValueVector|.

All primitive operations have a function type which is constructed using |(->)|. They don't have any further internal datatype representation (other than an identifier).

Lastly we also have propagation and renaming vectors that describe how the keys in a relation have changed. A propagation vector can be used for actual propagation of changes or to perform renaming.

\begin{code}
data PropVector = PVec [(OldPos, NewPos)]
data RenameVector = RVec [(OldPos, NewPos)]
\end{code}

The translation of types is trivial from here on:

\begin{infrules}
    \infrule[Prim]
        {}
        {| +- tp => Val |}
    \infrule[Flat-List]
        {}
        {| +- [tp] => NVector 1|}
    \infrule[Nested list]
        {| +- [t] => NVector i|}
        {| +- [[t]] => NVector (i + 1)|}
\end{infrules}

\section{To vector code}

In this section we will discuss how to translate the program to vector code. Some primitive functions, such as | op, insert, extract, | and | bPermute | are all represented the same in vectorised code (only their types change).

For other functions such as |dist| and |cons| more changes.

\begin{infrules}
    \infrule[v-lit]
        {| |}
        {| +- c => VConst 1 c |}
    \infrule[v-var]
        {| |}
        {| +- x => x |}\\
    \infrule[v-let]
        {| +- e1 => e1'| \quad | +- e2 => e2' |}
        {| +- let x = e1 in e2 => let x = e1' in e2' |}
    \infrule[v-binop]
        {| +- e1 => e1' |\quad | +- e2 => e2'|}
        {| +- e1 op e2 => e1' op e2' |}\\
    \infrule[index-1]
        {| +- e1 => e1' |\quad| +- e2 => e2' |}
        {| +- index (e1::[tc]) e2 => index_vec e1' e2' |}\\
    \infrule[index-2]
        {| let p be fresh |\\
         | +- e1 => patV d1 vs1 | \quad |+- e2 => e2'|\\
         | +~ chainPropagate p vs1 => e3|}
        {| index (e1::[[t]]) e2 => let p = index_desc d1 e2' in e3 |}\\
    \infrule[dist-1]
        {| +- e1 => e1'|\quad| +- e2 => e2'|}
        {| +- dist (e1::tc) e2 => dist_prim e1' (outer e2') |}\\
    \infrule[dist-2]
        {| let v be fresh | \\
         | +- e1 => e1'|\quad| +- e2 => e2'|}
        {| +- dist (e1::[tc]) e2 => let (v, _) = (dist_desc e1' (outer e2')) in attach (outer e2') v  |}\\
    \infrule[dist-3]
         {| let d, p be fresh |\\
          | +- e1 => e1'::(NVector n)|\quad | +- e2 => e2' |\\
          | +~ chainPropagate p (extract 1 e1') => e3|}
         {| +- dist e1 e2 => let (d, p) = dist_desc e1' (outer e2')
                              in patV (outer e2') (patV d e3) |}\\
    \infrule[dist-lift]
         {| let v be fresh |\\
          | +- e1 => e1'|\quad|e2 => patV d2 vs2|}
         {| +- distL (e1::[tc]) e2 => let (v, _) = dist_lift e1' (outer vs2) in attach d2 v|}\\
    \infrule[dist-lift2]
         {| let d, p be fresh |\\
          | +- e1 => patV d1 vs1 | \quad | +- e2 => patV d2 vs2 |\\
          | +~ chainPropagate p vs1 => e3|}
         {| +- distL e1 e2 => let (d, p) = dist_lift d1 (outer vs2) in  attach d2 (attach d e3)|}\\
    \infrule[cons-empty-1]
        {| +- e1 => (e1'::Val) |}
        {| +- e1 : [] => singleton_prim e1' |}
    \infrule[cons-empty-2]
        {| +- e1 => (e1' :: NVector n)|}
        {| +- e1 : [] => singleton_vec e1' |}\\ 
    \infrule[cons-1]
        {| let v be fresh |\\
         | +- e1 => e1'|\quad| +- e2 => e2' |}
        {| +- e1 : e2 => let (v, _, _) = append (singleton_prim e1') e2'
                          in v |}\\
    \infrule[cons-2]
        {| let v, p1, p2 be fresh|\\
         | +- e1 => e1' |\quad| +- e2 => patV d2 vs2 |\\
         | +~ renameOuter p1 e1' => r1|\quad| +~ renameOuter p2 vs2 => r2|\\
         | +~ r1 ++ r2 => e3 |}
        {| +- e1 : e2 => let (v, p1, p2) = append (outer (singleton_vec e1')) d2 in patV v e3|}\\
    \infrule[cons-lift-1]
        {| let v be fresh |\\
         | +- e1 => e1' |\quad | +- e2 => patV d2 vs2 |}
        {| +- (e1::[tc]) :^ e2 => let (v, _, _) = append (segment e1') vs2 in attach d2 v |}\\
    \infrule[cons-lift-2]
        {| let v, p1, p2 be fresh |\\
         | +- e1 => patV d1 vs1 |\quad| +- e2 => patV d2 vs2 |\\
         | +~ renameOuter p1 vs1 => r1 |\quad | +~ renameOuter p2 (extract 1 vs2 => r2)|\\
         | +~ r1  ++ r2 => e3|}
        {| +- e1 :^ e2 => let (v, p1, p2) = append (segment d1) (outer vs2) in patV d2 (patV v e3)|}\\
    \infrule[restrict-1]
        {| let v be fresh |\\
         | +- e1 => q1 |\quad| +- e2 => q2 |}
        {| +- restrict (e1::[tc]) e2 => let (v,_) = restrict_vec q1 q2 in v |}\\
    \infrule[restrict-2]
        {| let v, p be fresh |\\
         | +- e1 => patV d1 vs1|\quad| +- e2 => q2 |
         | +~ chainPropagate p vs1 => e3 |}
        {| +- restrict e1 e2 => let (v, p) = restrict_vec d1 q2 in patV v e3|}\\
    \infrule[combine-1]
        {| let v be fresh|\\
         | +- eb => qb | \quad | +- e1 => q1 | \quad | +- e2 => q2|}
        {| +- combine eb (e1::[tc]) e2 => let (v, _) = combine_vec qb q1 q2 in v|}\\
    \infrule[combine-2]
        {| let v, p1, p2 be fresh |\\
         | +- eb => qb | \quad | +- e1 => patV d1 vs1 | \quad | +- e2 => patV d2 vs2|\\
         | +~ renameOuter p1 vs1 => r1 | \quad | +~ renameOuter p2 vs2 => r2|\\ 
         | +~ r1 ++ r2 => e3|}
        {| +- combine eb e1 e2 => let (v, p1, p2) = combine_vec qb d1 d2 in patV v e3|}\\
    \infrule[bPermute]
        {| let v be fresh|\\
         | +- e1 => e1'|\quad| +- e2 => e2'|}
        {| +- back_permute e1 e2 => let (v, _) = bPermute_vec e1' e2' in v |}\\
    \infrule[length]
        {| e1 => q1 |}
        {| +- length e1 => length (outer q1)|}\\
    \infrule[length-lifted]
        {| +- (e1::[[a]]) => patV d1 vs1 |}
        {| +- lengthL e1 =>  rename (descToProp d1) (length_seg d1 (outer vs1)) |}\\
    \infrule[concat]
        {| +- e => patV d vs1 |}
        {| +- concat e => vs1 |}\\
    \infrule[concat-lifted]
        {| +- e => patV d (patV d' vs) |}
        {| +- concatL e => patV d (renameOuter (descToProp d') vs)|}\\
    \infrule[groupByS 1]
        {| +- e1 => v1 |\quad | +- e2 => v2|}
        {| +- groupByS e1 (e2::[tc]) => let (d, v, _) = groupBy v1 v2 in patV d v|}\\
    \infrule[groupByS 2]
        {| +- e1 => v1 |\quad | +- e2 => patV d2 vs |\\
         | +~ chainPropagate p vs => vs'|}
        {| +- groupByS e1 (e2::[[t]]) => let (d, v, p) = groupBy v1 v2 in patV d (patV v vs')|}\\
        \infrule[groupByL 1]
            {| +- e1 => patV d1 v1 |\quad| +- e2 => patV d2 v2 |}
            {| +- groupByL e1 (e2::[[tc]]) => let (d, v, _) = groupBy v1 v2 in patV d2 (patV d v)|}\\
        \infrule[groupByL 2]
            {| +- e1 => patV d1 v1 |\quad| +- e2 => patV d2 (patV d' vs2)|
             | +~ chainPropagate p vs2 => vs'|}
            {| +- groupByL e1 (e2::[[[t]]]) => let (d, v, p) = groupBy v1 d' in patV d2 (patV d (patV v vs'))|}
\end{infrules}

The rule dist-3 uses a meta function chainPropagate. The meta function propagateIn makes sure that the changes described by the propagation vector are propagated over all nesting levels. 

\begin{infrules}
    \infrule[chainP-n]
        {| n > 1|\quad | let p', v' be fresh | \\
         | +~ chainPropagate p' vs1 => e3|}
        {| +~ chainPropagate p (patV d1 vs1) => let (v', p') = propagateIn p d1 in patV v' e3|}\\
    \infrule[chainP-1]
        {| let v' be fresh|}
        {| +~ chainPropagate p (v::NVector 1) => let (v', _) = propagateIn p v in v'|}\\
    \infrule[append-Flat]
        {| let v be fresh|}
        {| +~ (e1::NVector 1) ++ e2 => let (v, _, _) = append e1 e2 in v|}\\
    \infrule[append-Nest]
        {| let v, p1, p2 be fresh |\\
         | +~ renameOuter p1 vs1 => e1' |\quad | +~ renameOuter p2 vs2 => e2' |\\
         | +~ e1' ++ e2' => e3|}
        {| +~ (patV d1 vs1) ++ (patV d2 vs2) => let (v, p1, p2) = append d1 d2 in patV v e3|}\\
    \infrule[rename-outer-flat]
        {| |}
        {| +~ renameOuter p (e::[tc]) => rename p e|}\\
    \infrule[rename-outer-nest]
        {| patV d1 vs1 = e|}
        {| +~ renameOuter p (e::[[t]]) => patV (rename p d1) vs1|}
\end{infrules}

\section{The |if| case}

So far only some primitive operations have been vectorised. All of these primitives where introduced by the flattening transformation. During the flattening transformation some language constructs where replaced by these primitive operations. Here these constructs occurred within a comprehension. It is not entirely unlikely that some constructs actually occur on the outside and contain nested lists. For most syntactic constructs we do not have to do anything special during vectorisation,but for the |if ... then ... else ... | construct however there is a case where we have to do some rewriting in terms of vector primitives. Namely, if the type of an if expression has a nesting depth greater then 1 we have to expand the construct.

\begin{infrules}
    \infrule[if-vec]
        {| +- eb => qb |\quad | +- e1 => patV q1 vs1 |\quad | +- e2 => patV q2 vs2|\\
         | (d1, p1) = restrict q1 (dist qb q1) | \quad | (d2, p2) = restrict q2 (dist (not qb) q2)| \\
         | +~ renameOuter p1 vs1 => r1 |\quad | +~ renameOuter p2 vs2 => r2|\\
         | +~ r1 ++ r2 => e3|}
        {| +- (if eb then e1 else e2) :: [[t]] => patV ((append d1 d2)@1) e3 |}
\end{infrules}

\section{Other primitive operations}

In this section we will give a definition of several other primitive operations that will be translated into vector operations.

\subsection*{Filter}

The function |filter| defined in Haskell as:
\begin{code}
filter :: (a -> Bool) -> [a] -> [a]
filter _    []                   = []
filter pred (x:xs)  | pred x     = x : filter pred xs
                    | otherwise  = filter pred xs
\end{code}

The translation to vector code is done by the following rule:

\begin{infrules}
        \infrule[filter]
            {| +- map f e => eb |\quad| +- e => e' |}
            {| +- filter f e => restrict e' eb |}
        \infrule[filter-lift]
            {| +- |}
            {| +- filter1 f e => |}
\end{infrules}

\section{Defining combinators in terms of primitive operations}

The provided primitive vector operations are used to define a set of combinators which can be used by the programmer.
