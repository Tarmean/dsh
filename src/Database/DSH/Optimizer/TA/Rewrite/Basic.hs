{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TupleSections   #-}

module Database.DSH.Optimizer.TA.Rewrite.Basic where

import           Debug.Trace
import           Text.Printf

import           Control.Applicative
import           Control.Monad
import           Data.Either.Combinators
import           Data.Maybe
import qualified Data.Set.Monad                             as S

import           Database.Algebra.Dag.Common
import           Database.Algebra.Dag(nodeMap)
import           Database.Algebra.Table.Lang

import           Database.DSH.Impossible
import           Database.DSH.Optimizer.Common.Rewrite
import           Database.DSH.Optimizer.TA.Properties.Types
import           Database.DSH.Optimizer.TA.Rewrite.Common

cleanup :: TARewrite Bool
cleanup = iteratively $ sequenceRewrites [ applyToAll noProps cleanupRules
                                         , applyToAll inferAll cleanupRulesTopDown
                                         , optimizeOrderConstraints
                                         ]

cleanupRules :: TARuleSet ()
cleanupRules = [ stackedProject
               , serializeProject
               -- , serializeRowNum
               ]

cleanupRulesTopDown :: TARuleSet AllProps
cleanupRulesTopDown = [ unreferencedRownum
                      , unreferencedRank
                      , unreferencedProjectCols
                      , unreferencedAggrCols
                      , postFilterRownum
                      , inlineSortColsRownum
                      , inlineSortColsSerialize
                      , inlineSortColsWinFun
                      ]


-- Apply some auxiliary rewrites before employing order
-- optimizations. The effect of auxiliary rewrites is only preserved
-- if at least one order rewrite succeeds.
optimizeOrderConstraints :: TARewrite Bool
optimizeOrderConstraints = 
    condRewrite $ iteratively $ iteratively (applyToAll inferAll auxRules)
                                >>
                                applyToAll inferAll orderRules

  where
    auxRules   = [ preserveOrderCols ]

    orderRules = [ inlineSortColsRownum
                 , inlineSortColsSerialize
                 , inlineSortColsWinFun
                 ]

----------------------------------------------------------------------------------
-- Rewrite rules

mergeProjections :: [Proj] -> [Proj] -> [Proj]
mergeProjections proj1 proj2 = map (\(c, e) -> (c, inline e)) proj1

  where
    inline :: Expr -> Expr
    inline (BinAppE op e1 e2) = BinAppE op (inline e1) (inline e2)
    inline (UnAppE op e)      = UnAppE op (inline e)
    inline (ColE c)           = fromMaybe (failedLookup c) (lookup c proj2)
    inline (ConstE val)       = ConstE val
    inline (IfE c t e)        = IfE (inline c) (inline t) (inline e)

    failedLookup :: Attr -> a
    failedLookup c = trace (printf "mergeProjections: column lookup %s failed\n%s\n%s"
                                   c (show proj1) (show proj2))
                           $impossible

stackedProject :: TARule ()
stackedProject q =
  $(dagPatMatch 'q "Project ps1 (Project ps2 (qi))"
    [| do
         return $ do
           let ps = mergeProjections $(v "ps1") $(v "ps2")
           logRewrite "Basic.Project.Merge" q
           void $ replaceWithNew q $ UnOp (Project ps) $(v "qi") |])


-- | Eliminate rownums which re-generate positions based on one
-- sorting column. These rownums typically occur after filtering
-- operators, i.e. select, antijoin, semijoin. If the absolute values
-- generated by the rownum are not required and only the encoded order
-- is relevant, we can safely remove the rownum and use the sorting
-- column. In that case, positions might not be dense anymore.
postFilterRownum :: TARule AllProps
postFilterRownum q =
  $(dagPatMatch 'q "RowNum args (q1)"
    [| do
        (res, [(sortCol, _)], _) <- return $(v "args")
        useCols <- pUse <$> td <$> properties q
        keys    <- pKeys <$> bu <$> properties $(v "q1")
        cols    <- pCols <$> bu <$> properties $(v "q1")

        -- To get rid of the rownum, the absolute values generated by
        -- it must not be required.
        predicate $ not $ res `S.member` useCols

        -- Rownum produces a key. If we remove the rownum because its
        -- absolute values are not needed and replace it with the
        -- original sorting column, it should still be a key.
        predicate $ (S.singleton sortCol) `S.member` keys

        -- If we reuse a sorting column, it's type should be int.
        predicate $ AInt == typeOf sortCol cols

        return $ do
          logRewrite "Basic.Rownum.Unused" q
          let projs = (res, ColE sortCol) : map (\c -> (c, ColE c)) (map fst $ S.toList cols)
          void $ replaceWithNew q $ UnOp (Project projs) $(v "q1") |])


---------------------------------------------------------------------------
-- ICols rewrites

-- | Prune a rownumber operator if its output is not required
unreferencedRownum :: TARule AllProps
unreferencedRownum q =
  $(dagPatMatch 'q "RowNum args (q1)"
    [| do
         (res, _, _) <- return $(v "args")
         neededCols  <- pICols <$> td <$> properties q
         predicate $ not (res `S.member` neededCols)

         return $ do
           logRewrite "Basic.ICols.Rownum" q
           replace q $(v "q1") |])

-- | Prune a rownumber operator if its output is not required
unreferencedRank :: TARule AllProps
unreferencedRank q =
  $(dagPatMatch 'q "[Rank | RowRank] args (q1)"
    [| do
         (res, _) <- return $(v "args")
         neededCols  <- pICols <$> td <$> properties q
         predicate $ not (res `S.member` neededCols)

         return $ do
           logRewrite "Basic.ICols.Rank" q
           replace q $(v "q1") |])

-- | Prune projections from a project operator if the result columns
-- are not required.
unreferencedProjectCols :: TARule AllProps
unreferencedProjectCols q =
  $(dagPatMatch 'q "Project projs (q1)"
    [| do
        neededCols <- pICols <$> td <$> properties q
        let neededProjs = filter (flip S.member neededCols . fst) $(v "projs")

        -- Only modify the project if we could actually get rid of some columns.
        predicate $ length neededProjs < length $(v "projs")

        return $ do
          logRewrite "Basic.ICols.Project" q
          void $ replaceWithNew q $ UnOp (Project neededProjs) $(v "q1") |])

-- | Remove aggregate functions whose output is not referenced.
unreferencedAggrCols :: TARule AllProps
unreferencedAggrCols q =
  $(dagPatMatch 'q "Aggr args (q1)"
    [| do
        neededCols <- pICols <$> td <$> properties q
        (aggrs, partCols) <- return $(v "args")

        let neededAggrs = filter (flip S.member neededCols . snd) aggrs

        predicate $ length neededAggrs < length aggrs

        return $ do
          case neededAggrs of
              -- If the output of all aggregate functions is not
              -- required, we can replace it with a distinct operator
              -- on the grouping columns.
              [] -> do
                  logRewrite "Basic.ICols.Aggr.Prune" q
                  projectNode <- insert $ UnOp (Project partCols) $(v "q1")
                  void $ replaceWithNew q $ UnOp (Distinct ()) projectNode

              -- Otherwise, we just prune the unreferenced aggregate functions
              _ : _ -> do
                  logRewrite "Basic.ICols.Aggr.Narrow" q
                  void $ replaceWithNew q $ UnOp (Aggr (neededAggrs, partCols)) $(v "q1") |])

----------------------------------------------------------------------------------
-- Basic Const rewrites

{-
isConstExpr :: Expr -> TAMatch AllProps
isConstExpr (BinAppE _ e1 e2) = (&&) <$> isConstExpr e1 <*> isConstExpr e2
isConstExpr (UnAppE _ e1)     = isConstExpr e1
isConstExpr (ConstE _)        = return True
isConstExpr (IfE e1 e2 e3)    = and <$> mapM isConstExpr [e1, e2, e3]
isConstExpr (ColE c)          = do
    properties $(v "

-- | Prune const columns from aggregation keys
constAggrKey :: TARule AllProps
constAggrKey q =
  $(dagPatMatch 'q "Aggr args (q1)"
    [| do
         (aggrFuns, keyCols@(_:_)) <- return $(v "args")
         keyCols' <- filterM (\(_, e) -> not <$> isConstExpr e) keyCols
         predicate $ length keyCols' < length keyCols

         return $ do
             logRewrite "Basic.Const.Aggr" q
             void $ replaceWithNew q $ UnOp (Aggr ($(v "aggrFuns"), keyCols')) $(v "q1") |])
-}

----------------------------------------------------------------------------------
-- Basic Order rewrites

-- | @lookupSortCol@ returns @Left@ if there is no mapping from the
-- original sort column and @Right@ if there is a mapping from the
-- original sort column to a list of columns that define the same
-- order.
lookupSortCol :: SortSpec -> Orders -> TAMatch AllProps (Either [SortSpec] [SortSpec])
lookupSortCol (oldSortCol, Asc) os =
    case lookup oldSortCol os of
        Nothing          -> return $ Left [(oldSortCol, Asc)]
        Just newSortCols -> return $ Right $ map (, Asc) newSortCols
lookupSortCol (_, Desc)         _  = fail "We only consider ascending orders"

inlineSortColsRownum :: TARule AllProps
inlineSortColsRownum q =
  $(dagPatMatch 'q "RowNum o (q1)"
    [| do
        (resCol, sortCols@(_:_), Nothing) <- return $(v "o")

        orders@(_:_) <- pOrder <$> bu <$> properties $(v "q1")

        -- For each sorting column, try to find the original
        -- order-defining sorting columns.
        mSortCols <- mapM (flip lookupSortCol orders) sortCols

        -- The rewrite should only fire if something actually changes
        predicate $ any isRight mSortCols

        let sortCols' = concatMap (either id id) mSortCols

        return $ do
          logRewrite "Basic.InlineOrder.RowNum" q
          void $ replaceWithNew q $ UnOp (RowNum (resCol, sortCols', Nothing)) $(v "q1") |])

inlineSortColsSerialize :: TARule AllProps
inlineSortColsSerialize q =
  $(dagPatMatch 'q "Serialize scols (q1)"
    [| do
        (d, RelPos cs, reqCols) <- return $(v "scols")
        orders@(_:_) <- pOrder <$> bu <$> properties $(v "q1")

        let cs' = concatMap (\c -> maybe [c] id $ lookup c orders) cs
        predicate $ cs /= cs'

        return $ do
            logRewrite "Basic.InlineOrder.Serialize" q
            void $ replaceWithNew q $ UnOp (Serialize (d, RelPos cs', reqCols)) $(v "q1") |])

inlineSortColsWinFun :: TARule AllProps
inlineSortColsWinFun q =
  $(dagPatMatch 'q "WinFun args (q1)"
    [| do
        let (f, part, sortCols, frameSpec) = $(v "args")
        (d, p, _) <- exposeEnv
        -- trace (printf "WinFun %d\n%s\n%s" q (show $ nodeMap d) (show p)) $ return ()

        orders@(_:_) <- pOrder <$> bu <$> properties $(v "q1")

        -- For each sorting column, try to find the original
        -- order-defining sorting columns.
        mSortCols <- mapM (flip lookupSortCol orders) sortCols

        -- The rewrite should only fire if something actually changes
        predicate $ any isRight mSortCols

        let sortCols' = concatMap (either id id) mSortCols
            args'     = (f, part, sortCols', frameSpec)

        return $ do
            logRewrite "Basic.InlineOrder.WinFun" q
            void $ replaceWithNew q $ UnOp (WinFun args') $(v "q1") |])

origCol :: Expr -> [Attr]
origCol (ColE c) = [c]
origCol _        = []

-- | If columns that define sort order are removed by a projection,
-- preserve them in the projection. This is an auxiliary rewrite for
-- the inlining of order columns into Serialize, RowNum and WinFun.
--
-- Be careful: This rewrite conflicts with the removal of no-longer
-- referenced columns (icols). It has to be used with rewrites that
-- make progress, otherwise we will end up in a rewriting loop.
preserveOrderCols :: TARule AllProps
preserveOrderCols q =
  $(dagPatMatch 'q "Project proj (q1)"
     [| do
         props <- properties $(v "q1")

         let cols      = liftM fst $ pCols $ bu props
             -- A mapping from old column name to new column name
             colMap    = [ (c', c) | (c, e) <- $(v "proj"), c' <- origCol e ]

             orders    = pOrder $ bu props

             -- Columns that are preserved by the projection (possibly
             -- under a new name)
             inCols  = S.fromList $ map fst colMap
             outCols = S.fromList $ map fst $(v "proj")

             -- Columns that do not survive the projection
             lostCols  = S.difference cols inCols

             -- All columns that are used to define orders in columns
             -- that survive the projection.
             orderCols = S.fromList 
                         $ concatMap snd
                         $ filter (\(oc, _) -> oc `S.member` inCols) orders

             -- Columns defining sort order that are removed by the
             -- projection.
             lostOrderCols = S.intersection orderCols lostCols

         predicate $ not $ S.null lostOrderCols
         let sortProj = zipWith (\i c -> ("ordcol" ++ show i, ColE c)) [1..] (S.toList lostOrderCols)

         predicate $ S.null $ S.intersection (S.fromList $ map fst sortProj) outCols

         return $ do
             -- Add lost sort columns in a projection.
             let proj' = $(v "proj") ++ sortProj

             n <- replaceWithNew q $ UnOp (Project proj') $(v "q1")

             logRewrite (printf "Basic.InlineOrder.PreserveOrderCols -> %d" n) q
             logGeneral $ printf "%s -> %s" (show lostOrderCols) (show proj')

             |])

----------------------------------------------------------------------------------
-- Serialize rewrites

-- | Merge a projection which only maps columns into a Serialize operator.
serializeProject :: TARule ()
serializeProject q =
    $(dagPatMatch 'q "Serialize scols (Project projs (q1))"
      [| do
          (d, p, reqCols) <- return $(v "scols")

          let projCol (c', ColE c) = return (c', c)
              projCol _            = fail "no match"

              lookupFail x xys = case lookup x xys of
                  Just y  -> return y
                  Nothing -> fail "no match"

          colMap <- mapM projCol $(v "projs")

          -- find new names for all required columns
          reqCols' <- mapM (\(PayloadCol c) -> PayloadCol <$> lookupFail c colMap) reqCols

          -- find new name for the descriptor column (if required)
          d' <- case d of
              Just (DescrCol c)  -> Just <$> DescrCol <$> lookupFail c colMap
              Nothing            -> return Nothing

          -- find new name for the pos column (if required)
          p' <- case p of
              AbsPos c  -> AbsPos <$> lookupFail c colMap
              RelPos cs -> RelPos <$> mapM (flip lookupFail colMap) cs
              NoPos     -> return NoPos

          return $ do
              logRewrite "Basic.Serialize.Project" q
              void $ replaceWithNew q $ UnOp (Serialize (d', p', reqCols')) $(v "q1") |])

{-
-- | If positions are computed directly under a Serialize operator,
-- try to get rid of it.  FIXME this rewrite should be based on the
-- order property, so that it considers rownums that are not located
-- directly under the serialize op.
serializeRowNum :: TARule ()
serializeRowNum q =
    $(dagPatMatch 'q "Serialize scols (RowNum args (q1))"
      [| do
          -- Absolute positions must not be required
          (d, RelPos cs, reqCols) <- return $(v "scols")

          -- The rownum must sort based on only one column which
          -- defines the order.
          (r, sortCols, Nothing) <- return $(v "args")
          predicate $ all ((== Asc) . snd) sortCols

          predicate $ r `elem` cs

          let cs' = concatMap (\c -> if c == r then map fst sortCols else [c]) cs

          return $ do
              logRewrite "Basic.Serialize.Rownum" q
              void $ replaceWithNew q $ UnOp (Serialize (d, RelPos cs', reqCols)) $(v "q1") |])
-}

