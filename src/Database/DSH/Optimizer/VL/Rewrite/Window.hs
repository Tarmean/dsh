{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE TemplateHaskell #-}
module Database.DSH.Optimizer.VL.Rewrite.Window where

import Debug.Trace

import           Control.Applicative
import           Control.Monad
import           Data.List.NonEmpty                              (NonEmpty (..))

import           Database.Algebra.Dag.Common

import           Database.DSH.Common.Lang
import           Database.DSH.Optimizer.Common.Rewrite
import           Database.DSH.Optimizer.VL.Properties.ReqColumns
import           Database.DSH.Optimizer.VL.Properties.Types
import           Database.DSH.Optimizer.VL.Properties.VectorType
import           Database.DSH.Optimizer.VL.Rewrite.Common
import           Database.DSH.VL.Lang

pattern SingleJoinPred e1 op e2 = JoinPred ((JoinConjunct e1 op e2) :| [])

-- Turn a running aggregate based on a self-join into a window operator.
runningAgg :: VLRule BottomUpProps
runningAgg q =
  $(dagPatMatch 'q "(_) AggrS afun (R1 ((Segment (Number (q1))) ThetaJoin p (Number (q2))))"
    [| do
        predicate $ $(v "q1") == $(v "q2")

        w <- vectorWidth <$> vectorTypeProp <$> properties $(v "q1")

        -- We require a range predicate on the positions generated by
        -- Number.
        -- FIXME allow other forms of window specifications
        SingleJoinPred (Column nrCol) GtE (Column nrCol') <- return $(v "p")
        predicate $ nrCol == w + 1 && nrCol' == w + 1

        -- The aggregate should only reference columns from the right
        -- ThetaJoin input, i.e. columns from the partition generated
        -- for a input tuple.
        let isWindowColumn c = c >= w + 2 && c <= 2 * w + 1
        predicate $ all isWindowColumn (aggrReqCols $(v "afun"))

        return $ do
            logRewrite "Window.RunningAggr" q
            -- Shift column references in aggregate functions so that
            -- they are applied to partition columns.
            let afun' = mapAggrFun (mapExprCols (\c -> c - (w + 1))) $(v "afun")

            -- The WinAggr operator /adds/ the window function output
            -- as a new column but keeps the old columns. Because we
            -- introduce WinAggr starting with Aggrs which only
            -- produces the aggregate output, we have to insert a
            -- projection to remove the original input columns and
            -- only keep the window function output.
            winNode <- insert $ UnOp (WinAggr (afun', WinLtEq)) $(v "q1")
            void $ replaceWithNew q $ UnOp (Project [Column $ w + 1]) winNode |])

inlineWinAggrProject :: VLRule BottomUpProps
inlineWinAggrProject q =
  $(dagPatMatch 'q "WinAggr args (Project proj (q1))"
    [| do
        w <- vectorWidth <$> vectorTypeProp <$> properties $(v "q1")

        return $ do
            logRewrite "Window.RunningAggr.Project" q

            let (afun, frameSpec) = $(v "args")
                env               = zip [1..] $(v "proj")
                -- Inline column expressions from the projection into
                -- the window function.
                afun'             = mapAggrFun (mergeExpr env) afun

                -- WinAggr /adds/ the window function output to the
                -- input columns. We have to provide the schema of the
                -- input projection to which the window function
                -- output is added.
                proj' = $(v "proj") ++ [Column $ w + 1]

            winNode <- insert $ UnOp (WinAggr (afun', frameSpec)) $(v "q1") 
            void $ replaceWithNew q $ UnOp (Project proj') winNode |])
